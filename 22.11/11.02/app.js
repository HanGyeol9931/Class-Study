// typeScript로 블록 생성 만들기

// 환경 설정 하고

// ts-node 설치

// 설치 명령어
// ------------------------------------------------
// npm install -D typescript ts-node @types/node
// ------------------------------------------------

// tsconfig.json 만들기

// ------------------------------------------------
// tsc --init
// ------------------------------------------------

// tsconfig.json에서 paths 사용할거라

// 설치 명령어
// ------------------------------------------------
// npm install -D tsconfig-paths
// ------------------------------------------------

// 우리가 필요한 모듈 설치

// 머클루트와 해시값이 필요하니까
// crypto-js, merkle 설치

// 설치명령어
// ------------------------------------------------
// npm install crypto-js merkle
// ------------------------------------------------

// typeScript는 외부 모듈을 사용할 경우에 타입 정의 파일이 필요하다.
// crypto-js , merkle 모듈 타입을 가져올 수 있는 모듈 설치

// 설치명령어
// ------------------------------------------------
// npm i --save-dev @types/crypto-js
// npm i --save-dev @types/merkle
// ------------------------------------------------

// 제네시스 블록 만들기

// 테스트 해보자

// 만든것들 테스트 해보자

// typeScript로 블록체인을 만들어봤는데 객체 지향적인 방법으로 코드를 작성하고
// OOP(객체 지향 프로그래밍)

// OOP는 프로그램의 설계방법 개념의 하나이다.

// OOP는 프로그램을 단순히 실행 데이터 처리 방법만이 아니라 
// 수많은 객체라는 단위를 만들어서 이 객체를 가지고 동작하는 상호작용을 서술한 방식이다.
// OOP에서 객체는 하나의 역활을 수행하는 함수와 변수들의 묶음 데이터로 보면 된다.

// 이런 객체지향 프로그래밍은 프로그램을 만들때 제일 작은 단위부터 만들어가는 방식을 선호함
// 근데 그러면 작성된 코드들의 테스트가 어렵고 어렵다는 단점이 있고 그래서 이런 부분들 떄문에 라이브러리를 사용해서
// 테스트 한다.

// 그냥 개발이 아니라 테스트 코드를 작성하면서 개발해나가는게 
// TDD(Test_Driven Development) 기법

// 그래서 우리도 테스트 해보려고 Jest라는 애를 써보자 

// 설치 명령어
// --------------------------------------------------
// npm install -D ts-jest @types/jest babel-core
// npm install -D @babel/preset-typescript @babel/preset-env
// --------------------------------------------------

// 체인 만들기

//  11-03
// block 클래스로 만든 블록들을 체인으로 연결시켜줄 chain을 클래스를 만들어 보자.
// chain 클래스에는 생성한 블록을 배열로 담아서 블록체인을 만들 예정이다.
// 이미 지금 우리가 만든 블록은 블록의 속성으로 체이닝 이미 이뤄지고 있는데
// 이전 블록 해시 값을 속성으로 가지고 있기 때문에 특정 블록기준으로 이전 블록 해시 값이 달라지면
// 현재 블록의 이전 해시값과 불일치가 발생해서 연결 고리가 끊긴다.
// chain클래스를 따로 만들어서 생성된 블록을 하나의 배열안에 감아주는 역활을 할 예정이다.

// 이렇게 하는 이유는 이후에 우리가 마이닝 할떄 난이도 계산을 하기 위해서 이다.

// POW (Proof of work : 작업 증명)

// 작업 증명 역사
// 작업증명의 기본 개념은 1933년도에 고안 되었고
// 1993년 모니 나노어이 작업 증명의 기본 개념을 고안했다.
// 1997년 영국의 암호학자인 애덤백의 해시캐시고 이후에 2009년 이 기술은
// 사토시 나카모토라는 사람이 비트코인 적용이 되어 오늘날까지 사용된다.

// 해시캐시는 대량을 스팸메일을 방지하고자 고안된 것.
// 이메일을 보내기 위해서 작업증명 알고리즘을 이용해서 해시값을 찾고
// 그 보상으로 발행 되는 우표 같은
// 이 과정이 시간과 비용이 많이들고 대량 발생되는 스팸메일을 막을수 있는 방법으로  이 방식을
// 사용했다.

// 작업증명 방식을 거래가 발생하면 해당 거래가 유용한지에 대한 합의 검증 방식.

// 논스값을 이제 사용 하고

// 간단히 설명

// 작업증명은 어려운 수학문제 푸는것 이라고 생각하고
// 채굴은 
// 작업증명을 하는 것이 체굴이다  라고 할 수 있다.
// 어려운 수학 문제를 풀게해서 이 문제를 푼사람한테 보상으로 코인을 주는것.

// 여기서 특정 조건을 만족하는 논스값을 찾는 것이다.

// 블록체인 상의 모든 참여자는 동일한 순서로 블록을 연결하기 위해서
// 합의 알고리즘이 필요하고
// 대표적인 합의 알고리즘은 POW, POS, DPOS, POA 등이 있다.

// 난이도가 4
// 논스 ???
// 0000이상인 해시값이 나올때까지 목표값이 나올때 까지
// 논스를 0에서 계속 하나씩 더하면서 해싱을 해서 목표값을 찾는것
// 0000 -> 000000

// "작업 증명 방식"은 POW는 목표값 이하의 해시 값을 찾는 과정을 무수히 반복해서
// 해당작업에 참여했음을 증명하는 방식의 알고리즘.

// 작업 증명 알고리즘은 필요성은 네트워크 상의 모든 노드가 동시에 블록을 만들수 없게 하는것.
// 작업증명을 통과해야만 새로운 블록을 추가 생성 할수 있게 된다는 점

// 작업 증명 알고리즘은 Difficulty 조절 알고리즘을 이용해서 약 10분당 1개의 블록이 생성 되는것을 보장하게 된다.

// 난이도 조절 블록 범위 => 10
// 블록의 생성 시간 (단위 : 분) => 10 
// 생성 시간 단위(단위 :초) => 60

// Difficulty 조절 알고리즘은 다음과 같이 설계하자

// 블록 한개가 생성디는 예상 시간을 10분으로 설정하고 , 10갸의 블록을 한 묶음으로 해서 블록 한 묶음이 생성되는
// 예상시간을 6000초라는 값을 할당해주고 이후 10갸의 블록이 생성되는데 걸리는 시간 timeExpected / 2  보다 작을 경우
// 난이도 조절을 1증가 시키고 timeExpected*2 보다 클 경우에는 난이도 1 감소 시키자

// P2P 네트워크

// block 클래스랑 chain를 가지고
// P2P네트워크 http / ws 환경 구성

// http / ws 환경 구성

// P2P네트워크를 만드는데 http와 ws 웹소켓을 사용해서
// api들을 구성하고 블록을 가져올 express모듈로 서버 동작을 하고 P2P 네트워크를 웹소켓으로 구성

// 설치할 모듈

// 설치 명령어

// express 와 express-type 설치
// ------------------------------------------------------
// npm install express
// npm install --save-dev @types/express
// ------------------------------------------------------

// ws 웹소켓 설치

// ------------------------------------------------------
// npm install ws
// npm install --save-dev @types/ws
// ------------------------------------------------------

// 트랜잭션

// 블록이 생성될때 우리 데이터 부분에 블록 몇번째 이렇게 문자로 담았는데.
// 비트코인 네트워크 트랜잭션
// 블록이 생성될때 블록안에 data 안에 트랜잭션을 담아준다.

// 블록이 생성되면 data에 트랜잭션을 담아주는데 이게 첫번째 트랜잭션은 코인베이스 트랜잭션
// 이라고 부르고 내용은 마이닝을 했을때 얻는 보상의 내용이 들어간다.
// 블록을 채굴하고 채굴한 사람이 얼마나 코인을 보상받았는지

// 트랜잭션 내용안에 객체로 표현되어있고
// UnspentTransactionOutput(UTXO)이 공간에 잔액을 객체로 저장
// 암호화폐에서 아직 사용 되지 않은 거래 출력 사용할수 있게 승인된 일정량의 디지털 화폐
// 사용되지 않은 미사용 객체

// 첫 번째 트랜잭션 코인베이스 트랜잭션
// Tx 0000 = {
// input : {},
// output : {주소 : 누구, 얻은 코인 : 50}
// }
// UTXO = [{주소 : 누구 , 얻은 코인 : 50, 참조 트랜잭션 : Tx 0000 }]
// UTXO안에 있는 객체를 수정하는것이 아니라 삭제하고 새로운 객체를 넣어주는것

// Tx 0001 = {
// input : {주소 : 누구 , 코인 : 50, 참조 트랜잭션 : Tx 0000},
// output : [{주소 : 너,코인 : 1},{주소 : 누구, 얻은 코인 : 49}]
// }

// UTXO에서  {주소 : 누구 , 얻은 코인 : 50, 참조 트랜잭션 : Tx 0000 }를 제거하고
// UTXO = [{주소 : 너 , 얻은 코인 : 1, 참조 트랜잭션 : Tx 00001 },{주소 : 누구 , 얻은 코인 : 49, 참조 트랜잭션 : Tx 00001 }]

// "누구"라는 사용자가 "너"에게 50코인에서 1코인을 보낸다고 가정해서
// input에 Tx 0000 트랜잭션을 속성값으로 전달하고 output에는 두객체
// {주소 : 너,코인 : 49, 참조 트랜잭션 : Tx0001} 객체가 만들어 지고
// 이 두 객체를 통해서 만들어진 내용이 UTXO에 객체로 담기게 된다. (미사용 객체)
// {주소 : 누구 , 코인 : 50, 참조 트랜잭션 : Tx 0000} 사용된 객체는 제거

// Tx 0002 = {
// input : {주소 : 누구 , 코인 : 49, 참조 트랜잭션 : Tx 0001 },
// output : [{주소 : 너,코인 : 20},{주소 : 누구, 얻은 코인 : 29}]
// }

// UTXO = [{주소 : 너 ,코인 ; 1},{주소 : 너,코인 : 20},{주소 : 누구 ,코인 29}]
// UTXO라는 공간은 트랜잭션의 내용을 구성해서  거래 내용을 기록해놓기 위함

// Tx 0003 = {
// input : [{주소 : 너 , 코인 : 1, 참조 트랜잭션 : Tx 0001 },{주소 : 너 , 코인 : 20, 참조 트랜잭션 : Tx 0002 }]
// output : [{주소 : 누구, 얻은 코인 : 29}]
// }
// UTXO = [{주소 : 누구 ,코인 29 ,참조 트랜잭션 : Tx 0002},{주소 : 누구 ,참조트랜잭션 : Tx0003}]

// 지갑 프로그램에서 사용자 계정 A, B가 있고
// A가 B한테 10 BTC의 전송을 보내면 지갑서버에서 요청을 받아서 
// 서명과 트랜잭션 데이터를 만들고 블록체인 서버 쪽에 해당 데이터를 전송
// 블록체인 서버에서 트랜잭션 객체를 만들어 준다.

// 트랜잭션 객체가 생겼을때 UTXO 배열 안에서 unspentTxOut 객체를 제거하고 트랜잭션을 통해
// 새로 생긴 unspentTxOut 객체들을 UTXO에 추가 시켜주는 작업
// UTXO 내용을 업데이트 해준다.

// 트랜잭션 풀 이라는 공안을 만들고 트랜잭션 객체가 생성되었을때 만들어진 트랜잭션을
// 트랜잭션 풀에 담아준다. 그리고 블록체인 네트워크 상에 연결된 노드들은 트랜잭션 풀의 내용을
// 공유한다. 블록 마이닝 할때 트랜잭션 풀 안에 있는 트랜잭션 객체를 사용해 새로 생성되는 블록의
// data 속성 값으로 넣어준다.
// 그래서 필요한게 블록이 마이닝 될때 트랜잭션 풀을 업데이트 해주는 부분이 필요

// 노드들이 트랜잭션 풀의 내용을 공유한느 부분은 트랜잭션 객체가 생겼을때 트랜잭션 객체를
// 보드캐스트 하는 방식 

// 윈도우에 geth를 설치해서 쓰면 더 쉬운데 맥 사용자들이 있어서 
// 예전엔 윈도우를  Linux 쓰려면 가상머신을 설치해서 사용해야됐는데

// 컴퓨터나 메모리나 CPU 등등 자원을 쪼개서 OS를 따로 설치해서  사용할수 있는데
// 이러면 컴퓨터 성능이 저하되기 떄문에 비효율 적인 단점이 있다.
// WSL은 이 단점을 보완하고 개발 환경을 쉽게 구축 가능하다.

// WSL2를 설치해서 사용한다.
// 윈도우에서도 Linux 명령어를 사용할수 있게 도와주는 툴(WSL2)

// 제어판 -> 프로그램 -> 프로그램 및 기능 -> windows 기능 켜기/끄기
// Liunx용 Windows 하위 시스템  or windows Subsystem for Liunx 이걸 체크

// 윈도우 키 + S 검색창에 설정 검색 -> 시세템정보 -> 정보 -> 윈도우 버전 확인
// cmd 창을 관리자 권한으로 실행
// 명령어 붙여 넣기
// 배포 이미지 서비스 및 관리 대한 부분
// dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
// Virtual Machine Platfrom 기능 활성화 부분
// dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart

// 설치할 수 있는 배포 목록 확인 명령어
// wsl -l -o
// wsl --install -d Ubuntu
// 터미널 창에서 우분투 접속은 wsl만 치면 되고 

// wsl의 list와 version을 볼수 있는 명령어
// wsl -l -v

// wsl2로 버전없을 할 건데
// 링크 https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi
// wsl --set-default-version Ubuntu 2
// wsl --set-default-version Ubuntu 2



// 21H2 
// https://support.bluestacks.com/hc/ko/articles/360058102252-%EB%B8%94%EB%A3%A8%EC%8A%A4%ED%83%9D5-Windows-10%EC%97%90%EC%84%9C-%EA%B0%80%EC%83%81%ED%99%94-VT-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%98%EA%B8%B0
// 가상화 활성화


